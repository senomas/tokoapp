import {
  cubicInOut
} from "./chunk-BEBZQU6U.js";
import {
  loop,
  noop,
  now
} from "./chunk-PIC67VNU.js";
import "./chunk-XJRAAFMK.js";

// node_modules/svelte-scrollto/src/helper.js
var helper_default = {
  $(selector) {
    if (typeof selector === "string") {
      return document.querySelector(selector);
    }
    return selector;
  },
  extend(...args) {
    return Object.assign(...args);
  },
  cumulativeOffset(element) {
    let top = 0;
    let left = 0;
    do {
      top += element.offsetTop || 0;
      left += element.offsetLeft || 0;
      element = element.offsetParent;
    } while (element);
    return {
      top,
      left
    };
  },
  directScroll(element) {
    return element && element !== document && element !== document.body;
  },
  scrollTop(element, value) {
    let inSetter = value !== void 0;
    if (this.directScroll(element)) {
      return inSetter ? element.scrollTop = value : element.scrollTop;
    } else {
      return inSetter ? document.documentElement.scrollTop = document.body.scrollTop = value : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
    }
  },
  scrollLeft(element, value) {
    let inSetter = value !== void 0;
    if (this.directScroll(element)) {
      return inSetter ? element.scrollLeft = value : element.scrollLeft;
    } else {
      return inSetter ? document.documentElement.scrollLeft = document.body.scrollLeft = value : window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
    }
  }
};

// node_modules/svelte-scrollto/src/index.js
var defaultOptions = {
  container: "body",
  duration: 500,
  delay: 0,
  offset: 0,
  easing: cubicInOut,
  onStart: noop,
  onDone: noop,
  onAborting: noop,
  scrollX: false,
  scrollY: true
};
var _scrollTo = (options) => {
  let {
    offset,
    duration,
    delay,
    easing,
    x = 0,
    y = 0,
    scrollX,
    scrollY,
    onStart,
    onDone,
    container,
    onAborting,
    element
  } = options;
  if (typeof offset === "function") {
    offset = offset();
  }
  var cumulativeOffsetContainer = helper_default.cumulativeOffset(container);
  var cumulativeOffsetTarget = element ? helper_default.cumulativeOffset(element) : { top: y, left: x };
  var initialX = helper_default.scrollLeft(container);
  var initialY = helper_default.scrollTop(container);
  var targetX = cumulativeOffsetTarget.left - cumulativeOffsetContainer.left + offset;
  var targetY = cumulativeOffsetTarget.top - cumulativeOffsetContainer.top + offset;
  var diffX = targetX - initialX;
  var diffY = targetY - initialY;
  let scrolling = true;
  let started = false;
  let start_time = now() + delay;
  let end_time = start_time + duration;
  function scrollToTopLeft(element2, top, left) {
    if (scrollX)
      helper_default.scrollLeft(element2, left);
    if (scrollY)
      helper_default.scrollTop(element2, top);
  }
  function start(delayStart) {
    if (!delayStart) {
      started = true;
      onStart(element, { x, y });
    }
  }
  function tick(progress) {
    scrollToTopLeft(container, initialY + diffY * progress, initialX + diffX * progress);
  }
  function stop() {
    scrolling = false;
  }
  loop((now2) => {
    if (!started && now2 >= start_time) {
      start(false);
    }
    if (started && now2 >= end_time) {
      tick(1);
      stop();
      onDone(element, { x, y });
    }
    if (!scrolling) {
      onAborting(element, { x, y });
      return false;
    }
    if (started) {
      const p = now2 - start_time;
      const t = 0 + 1 * easing(p / duration);
      tick(t);
    }
    return true;
  });
  start(delay);
  tick(0);
  return stop;
};
var proceedOptions = (options) => {
  let opts = helper_default.extend({}, defaultOptions, options);
  opts.container = helper_default.$(opts.container);
  opts.element = helper_default.$(opts.element);
  return opts;
};
var scrollContainerHeight = (containerElement) => {
  if (containerElement && containerElement !== document && containerElement !== document.body) {
    return containerElement.scrollHeight - containerElement.offsetHeight;
  } else {
    let body = document.body;
    let html = document.documentElement;
    return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
  }
};
var setGlobalOptions = (options) => {
  helper_default.extend(defaultOptions, options || {});
};
var scrollTo = (options) => {
  return _scrollTo(proceedOptions(options));
};
var scrollToBottom = (options) => {
  options = proceedOptions(options);
  return _scrollTo(helper_default.extend(options, {
    element: null,
    y: scrollContainerHeight(options.container)
  }));
};
var scrollToTop = (options) => {
  options = proceedOptions(options);
  return _scrollTo(helper_default.extend(options, {
    element: null,
    y: 0
  }));
};
var makeScrollToAction = (scrollToFunc) => {
  return (node, options) => {
    let current = options;
    const handle = (e) => {
      e.preventDefault();
      scrollToFunc(typeof current === "string" ? { element: current } : current);
    };
    node.addEventListener("click", handle);
    node.addEventListener("touchstart", handle);
    return {
      update(options2) {
        current = options2;
      },
      destroy() {
        node.removeEventListener("click", handle);
        node.removeEventListener("touchstart", handle);
      }
    };
  };
};
var scrollto = makeScrollToAction(scrollTo);
var scrolltotop = makeScrollToAction(scrollToTop);
var scrolltobottom = makeScrollToAction(scrollToBottom);
export {
  makeScrollToAction,
  scrollTo,
  scrollToBottom,
  scrollToTop,
  scrollto,
  scrolltobottom,
  scrolltotop,
  setGlobalOptions
};
//# sourceMappingURL=svelte-scrollto.js.map
